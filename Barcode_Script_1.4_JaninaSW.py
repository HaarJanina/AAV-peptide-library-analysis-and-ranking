#!/usr/bin/env python
#__________________________________________________________________________DNA-BARCODE-SCRIPT 1.4___________________________________________________________________________
#
#a script to analyze sequencing data generated by Illumina platforms. Demultiplexing and barcode variation attribution can be performed. 
#(for more information see the instruction files)

#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

import gzip
import os

print "\n"*15+"====== Barcode Script 1.4 (modified by S.Weis, J. Sippel and J. Weinmann) ======\n\n"

#open config-file and extract the defined variables
config={}
execfile("//netfile1.bioquant.uni-heidelberg.de/RedirDesktops/bq_jhaar/Desktop/NGS Script/Barcode_Script_Janina.conf") 
samples={"":""}
print vars()

basepair={'T':'A', 'A':'T', 'G':'C', 'C':'G'}

def rev_comp(sequence, basepair):
    sequence_rev=sequence[::-1]
    sequence_rev_comp=''
    for i in range(0,len(sequence_rev),1):
        base=sequence_rev[i]
        sequence_rev_comp += basepair[base]
    return sequence_rev_comp

#if samples_name exists, the samples and their corresponding index sequences are stored in a ditionary called samples: {index:sample}; if sample_name is empty, all values are set to 0/''
#samples_name -> demult_indexes
if not "samples_name" in vars() or samples_name=="":
    samples_name=""
    BCS1_size=0
    BCS2_size=0
    BCS1_right=""
    BCS2_left=""  
else:  
    with open(samples_index_file) as temp:
        samples=dict(line.strip().split() for line in temp if line.strip())


#the file called reads_name is opened and the length of the barcode-sequence is determined; the structure of the output-variable results is created: {sample:{barcode:variant=0}}
reads_input=""
print my_dir
objects=os.listdir(my_dir)
for i in range(0,len(objects)):
    filename=objects[i]
    reads=gzip.open(my_dir+filename, 'rb')
    reads_input=filename
    read_count=0
    good_reads=0
    results={}
    print "\n"*10+"Sample being processed: %s" %reads_input
    print "\n""Script is running...\n"
    for n in samples:
        results[samples[n]]={}
    
    #for each line in the read_name-file, check if it is a DNA-sequence: If this is the case, store the sequence in line and increment read_count. If this is not the case, go to the next line
    for ln in reads:
        if not ln.strip():
            continue
        for i in ln.upper().strip():
            if not i or i not in ["A","T","G","C"]:
                noDNA=True
                break
            noDNA=False
        if noDNA:
            continue
        line=ln.strip().upper()
        read_count+=1

    	#both indexes are searched for here (right and left). Not needed for my analysis since demultiplexing is already done.
    	#I left it in to keep the script modular.
    	#if the demultiplexing-variables are not defined in the config-file, BCS is always: ''
        if line[BCS1_size:BCS1_size+len(BCS1_right)]==BCS1_right.upper() and line[len(line)-BCS2_size-len(BCS2_left):len(line)-BCS2_size]==BCS2_left.upper():
            BCS=line[0:BCS1_size]+line[len(line)-BCS2_size:len(line)]
        else:
            continue

    	#search for the the barcode-sequence of the read and store it in the variable BCV: If the constant hexamers are not found, the next read is analysed (no increment of good_reads or best_reads)
    	# find is defined by arguments in brackets, result is the position, where the first argument (first in the bracket) is found
    	#A is right constant hexamer, B is left constant hexamer. D and E are the reverse complement constant hexamers left and right.
    	#rfind gives you the position of the LAST occurence of your search term
        A=line.find(BCV_right,BCV_loc-BCV_margin+BCV_size)
        B=line.find(BCV_left,BCV_loc-BCV_margin-len(BCV_left))
        C=line.rfind(BCV_right,BCV_loc-BCV_margin+BCV_size,BCV_loc+BCV_margin+BCV_size+len(BCV_right))
        D=line.find(BCV_right_revcomp,BCV_loc_revcomp-BCV_margin+BCV_size)
        E=line.find(BCV_left_revcomp,BCV_loc_revcomp-BCV_margin-len(BCV_left))
        F=line.rfind(BCV_right_revcomp,BCV_loc_revcomp-BCV_margin+BCV_size,BCV_loc_revcomp+BCV_margin+BCV_size+len(BCV_right))
        if A-B==BCV_size+len(BCV_left):
            BCV=line[B+len(BCV_left):A]
        elif C-B==BCV_size+len(BCV_left):
            BCV=line[B+len(BCV_left):C]
        elif D-E==BCV_size+len(BCV_left):
            BCV_rev=line[E+len(BCV_left):D]
            BCV=rev_comp(BCV_rev, basepair)
        elif F-E==BCV_size+len(BCV_left):
            BCV_rev=line[E+len(BCV_left):F]
            BCV=rev_comp(BCV_rev, basepair)
        else:
            continue
        
        #if the index sequence of the read can be matched with a sample stored in the variable samples, good_reads is incremented
        if BCS in samples:
            good_reads+=1
            if BCV in results[samples[BCS]]:
                results[samples[BCS]][BCV]+=1
            else:
                results[samples[BCS]][BCV]=1

    #create output file
    output_file=my_dir+filename 
    new_output_file=output_file.replace("txt.gz","txt")
    f=open(new_output_file,'w')
    f.write("====== Generated with Barcode Script 1.4 ======\n\n")
    f.write("\nTotal number of reads: "+str(read_count))
    f.write("\nReads recovered: "+str(good_reads))
    print "\nTotal number of reads: "+str(read_count)
    print "Reads recovered: "+str(good_reads)
    for n in sorted(results,key=str.lower):
        if "output_file" in vars() and output_file!="":
            f.write("\nSample:"+n+"\t"+"# \n")

        for i in sorted(results[n],key=str.lower):
            if "output_file" in vars() and output_file!="":
                f.write(i+"\t"+str(results[n][i])+"\n")

    if "output_file" in vars() and output_file!="":
        f.write("\n")
        f.close()
    print "====== Script completed! ======"
